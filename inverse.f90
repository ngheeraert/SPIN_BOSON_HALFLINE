! ==============================================================================
!  MODULE: inverse.f90 (INVERSE)
!
!  PURPOSE & CONTEXT
!    Specialized linear algebra module for the waveguide QED simulation. 
!    It provides the specific tensor-reshaping algorithms required to solve 
!    the implicit Euler-Lagrange equations generated by the Time-Dependent 
!    Variational Principle (TDVP).
!
!  CORE RESPONSIBILITIES
!    1. Tensor Flattening : Implements `directInverse` to map 3-index tensors 
!                           onto 2D matrices. This converts the $O(N_{modes} N_{cs}^3)$ 
!                           problem into an $O(N_{cs}^6)$ dense matrix inversion.
!    2. Math Utilities    : Provides the Kronecker delta function used during 
!                           the construction of the variational system matrices.
! ==============================================================================

MODULE INVERSE

  USE consts
  USE lapackmodule
  USE typedefs, only : cx => c_type, rl=> r_type
  IMPLICIT none


  CONTAINS

  !> -------------------------------------------------------------------------
  !> SUBROUTINE: directInverse
  !> -------------------------------------------------------------------------
  !> Purpose / context:
  !>   Solves the block-structured linear system required to decouple the 
  !>   variational derivatives. 
  !>   
  !>   Physics Context (Appendix of N. Gheeraert et al. 2017):
  !>   The TDVP equations yield an implicit relation where the unknown amplitudes 
  !>   $\kappa_{j,k}$ are coupled via a 3-index overlap tensor $A(i,j,k)$. 
  !>   To solve this using standard linear algebra, this routine "flattens" 
  !>   the $(i,j)$ block indices into a single row index, and $(j,k)$ into a 
  !>   column index. It builds a dense $N_{cs}^2 \times N_{cs}^2$ matrix (`A2D`), 
  !>   adds the identity constraint along the secondary diagonal blocks, and 
  !>   dispatches it to LAPACK for direct inversion.
  !> Arguments:
  !>   - n   : Block size (Current number of polarons / coherent states, $N_{cs}$).
  !>   - A   : Input 3D tensor of variational coefficients.
  !>   - sol : Output flattened solution vector (size $N_{cs}^2$).
  !>   - rhs : Input flattened Right-Hand Side driving vector.
  !>
  subroutine directInverse(n,A,sol,rhs)
    complex(cx),intent(in)     :: A(n,n,n)
    complex(cx),intent(in)     :: rhs(n**2)
    complex(cx),intent(in out) :: sol(n**2)
    complex(cx)           :: A2D(n**2, n**2)
    integer               :: n,nn, i,j,k  !-- n=block size, nn=array size


    !-- Build Matrix
    A2D=0._cx
    do i=1, n
      do j=1, n
        do k=1, n
          A2D((j-1)*n+i,(j-1)*n+k)=A(i,j,k)
        end do
        A2D((j-1)*n+i,(i-1)*n+j)=1.0_cx
      end do
    end do
    ! -- resolve
    sol=rhs
    Call solveEq_c(A2D, sol)
  end subroutine directInverse

  !> -------------------------------------------------------------------------
  !> FUNCTION: kroneckerDelta
  !> -------------------------------------------------------------------------
  !> Purpose / context:
  !>   Mathematical utility evaluating the discrete Kronecker delta function 
  !>   $\delta_{a,b}$. Returns 1.0 if the indices match exactly, and 0.0 otherwise.
  !>   Used primarily to construct the diagonal blocks and identity matrices 
  !>   when packing the `A2D` tensor arrays in the TDVP solver.
  !> Arguments:
  !>   - a : First integer index.
  !>   - b : Second integer index.
  !> Return:
  !>   - real(rl) : The evaluated scalar (1.0 or 0.0).
  !>
  FUNCTION kroneckerDelta(a,b)

 		integer,intent(in)   ::  a,b
 		real(rl)				   ::  kroneckerDelta

 		if (a==b) then
 		  kroneckerDelta = 1
 		else
 		  kroneckerDelta = 0
 		end if
  END FUNCTION


END MODULE INVERSE
